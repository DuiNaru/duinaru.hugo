[{"title":"AWS summit online japan 2021 2일차 후기","date":"","description":"2021년 5월 11일 부터 2일간 개최된 AWS summit online japan에 참가해보았습니다.","body":"매년 열리는 AWS summit, 작년부터 COVID-19로 인해 온라인으로 진행되고 있습니다.\n올해는 5월 12일 부터 13일까지 양일간에 걸쳐 라이브로 진행되고 31일 까지 개최됩니다.\naws summit online japan\n필자는 라이브로 진행되는 양일간에 걸쳐 참가하였으며, 각 내용을 정리해 볼까 합니다.\n2일차 2일차에는 개발이나 서버리스 등 실제로 만들어 보는 내용에 관련된 세션 주로 참가하였습니다.\n마지막 날 인만큼, 특별강연까지 기나긴 하루였습니다.\n기조강연 전날과는 다르게 영어로 대부분이 진행되며, 일본어 자막이 지원되었습니다. AWS의 신념에 대해 말하기 시작해 다양한 서비스를 소개하고 AWS 커스텀 실리콘에 대해 이야기를 하면서 중간중간 관계회사분들의 이야기를 들을 수 있었습니다.\n1일차에 purpose-built databases에 대해 인상깊었는데, 이번에는 기조강연에서 언급하면서 데이터의 중요성을 강조한 것도 인상깊었습니다.\n세션 총 9개의 세션에 참가, 점심먹기도 힘들었던 기억이 나네요.\n웹, 모바일어플리케이션 개발을 가속시키는 AWS Amplify 제목 그대로의 AWS Amplify 소개 세션\n이전에 GraphQL이 궁금해서 찾아보던중 알게된 서비스, 인프라의 대부분을 간략화시켜서 설정하고, 백엔드와 프론드엔드단의 코드를 생성해 주기도 하는 등 어플리케이션의 개발을 편리하게 해주는 서비스입니다.\n이번에 Admin UI가 생겼다고도 하네요.\nAWS Amplify와 AWS AppSync를 사용한 풀스택 어플리케이션 개발 이전의 AWS Amplify에 이어서 AWS AppSync를 이용한 구체적인 개발 사례 소개 세션입니다.\nAWS Amplify와 AWS AppSync를 사용한 아키텍쳐를 바탕으로 인증방법, Graph API 작성 방법, 리액트 코드 자동 생성 등 비디오 채팅 어플리케이션 개발을 예제로 설명합니다.\n이건 한번 만들어 보고 싶어지는 군요.\nAWS에서의 네트워크 \u0026amp; 어플리케이션 보호의 단계 이번 세션에서는 시큐리티 위주의 설명이 주로 되었습니다.\nSYN floods나 SQL인젝션, 크롤러 등 보안에 위험이 될 수 있는 요소를 AWS에서는 AWS Network Firewall, AWS WAF, AWS Shield Advanced로 보호할 수 있다고 합니다.\n각 서비스를 이용한 구성과 설명이 있는 세션이였습니다.\nAWS로 시작하는 Infrastructure as Code 제목을 부터 AWS CloudFormation이 느껴지는 세션이였습니다. 역시나 AWS CloudFormation의 설명이 있더군요.\nAWS 환경을 코드로 관리하는 것에 대한 설명, 필요성, 목적 등에 대해 이야기 한 다음에 CloudFormation의 설명과 예제로 이어졌습니다.\n다만, yml로 알고 있던 CloudFormation을 Cloud Develop Kit을 이용하여 프로그래밍 언어로 작성 할 수 있다고 하는 점이 신선했습니다.\n변수 같이 프로그래밍 쪽 요소를 넣어서 구성하기에 편해보였습니다.\n이노베이션을 가속하는 서버리스 어플리케이션의 이벤트 구동형 아키텍쳐 어제도 보았던 서버리스! 지나칠 수 없지요.\nAWS Lambda에 대한 설명을 포함해, 서버리스 어플리케이션의 필요성 그리고 이벤트 구동형 아키텍쳐에 대한 설명이 있었습니다.\n이벤트 구동형 아키텍쳐에 대한 내용을 처음 들어서 생소하였지만, 흥미로웠네요.\n그리고 Lambda와 관련 서비스에 대한 설명도 있었습니다.\nAWS에서의 컨테이너 워크로드에 대해, 다양한 빌딩블록의 선택지 컨테이너의 필요성과 이점에 대해 궁금한 부분이 있어서 참석해보았습니다.\nAWS의 컨테이너 관련 서비스인 AWS Fargate, EKS, ECS, ECR 등에 대한 설명과 ECS/EKS의 비교에 대한 이야기도 있었습니다.\n그리고, AWS CodePipeline등을 이용한 자동화 방법에 대한 설명도 있었네요.\n컨테이너, 서버리스를 사용하면 모던 어플리케이션이 되는가? 제목부터 범상치 않은 기운이 느껴질 듯 한 세션, 설계의 중요성을 깨닫는 세션이였습니다.\n예제 어플리케이션의 문제점을 하나하나 집어가면서 관련 서비스를 소개하고 해결해 나가는 방식으로 이해를 돕는 진행방식이 인상적 이였습니다.\n제목과 같이 생각하고 있던 분들이라면 추천하고 싶은 세션입니다.\n내일부터 시작할 수 있다!! Chaos Engineering의 시작 가이드 Chaos Engineering?? 뭘까요? 참가!!\n 시스템이 서비스 환경에서 불안정한 상태를 버틸 수 있게 하는 것\n 위의 내용의 근거를 마련하는 것이 Chaos Engineering라고 합니다.\n아무리 철저히 테스트를 하더라도 서비스중에는 터지기 마련이고, 그에 대한 준비가 필요하다는 것은 엔지니어라면 느끼고 계시겠지요.\n이를 실제로 해 보는 것이 Chaos Engineering! 간단하게 말하면 서비스 중인 인스턴스를 정지시켜서 어떤 변화가 생기는지 살펴보는 방법이라고 합니다.\n현재의 시스템이 Well-Architected 되어있고, Observabilty가 되어있는 상태에서 도입해야 가치가 있다고 하는 군요.\n Without observability,\nyou don\u0026rsquo;t have chaos engineering.\nYou just have Chaos.\nCharity Majors\nCofounder/CTO honeycomb.io\n 세션의 일부를 인용해봤습니다. Chaos Engineering를 해보겠다고 Chaos를 해서는 안되겠지요.\n제목처럼 내일부터 시작할 수 있을지는 잘 모르겠지만, 흥미로운 세션이였습니다.\nOpen-source observability at AWS - 가관측성을 지탱하는 OSS와 AWS의 \u0026ldquo;지금\u0026quot;을 알자 2일차 마지막 세션이자, 바로 전 세션에서 들은 observability 에 대한 세션입니다.\n엔지니어라면 디버그에서의 스택 트레이스, 에러 로그 분석 등 무언가 문제가 발생하면 원인을 찾기위해 이것저것 살펴보고는 하지요.\n그들은 문자라는 것을 읽어야 이해가 되며, 전체를 보기 위해서는 많은 시간을 필요로 합니다.\n이것을 한 눈에 알아볼 수 있게 할수 있다면, 많은 시간을 절약할 수 있겠지요.\n이를 도와주는 AWS의 서비스와 OSS, 그리고 이 둘을 합친 서비스를 소개하는 세션이였습니다.\nOSS인 Fluentd, Fluentd Bit, Prometheus, Cortex, OpenTelemetry과 AWS X-Ray. FireLens for ECS/EKS, Amazon Managed Service for Prometheus/Grafana , AWS Distro for OpenTelemetry 등 가관측성을 도와주는 서비스에 관심을 가지시고 계신다면, 한번쯤 참가해볼만 세션이라고 생각되었습니다.\n특별강연 AWS summit online의 막을 내리는 시간, 미래는 어떻게 바뀌고 바뀌어 나갈건지 등에 대해 관계자들이 나와서 서로 이야기를 주고받는 방식으로 진행되었습니다.\n2일차 후기 흥미로운 주제가 많아서 이것저것 듣다보니 2일이 지났습니다.\n알고 있던 것도 새로운 부분을 알게 되고, 모르는 것은 더욱 더 알아가게 되는 시간이였습니다. 고민거리에 대한 답을 생각해보기도 하고, 재미있어 보이는 것들도 있었네요.\nCOVID-19로 인해, 현장에서 직접 듣거나 파트너 부스를 돌아다닐수 없게 된 점은 어쩔 수 없다고 생각되며, 다음에는 오프라인에서 만나 볼 수 있었으면 하고 바랍니다.\n","ref":"/posts/2021-05-17-aws-summit-online-day2/"},{"title":"AWS summit online japan 2021 1일차 후기","date":"","description":"2021년 5월 11일 부터 2일간 개최된 AWS summit online japan에 참가해보았습니다.","body":"매년 열리는 AWS summit, 작년부터 COVID-19로 인해 온라인으로 진행되고 있습니다.\n올해는 5월 12일 부터 13일까지 양일간에 걸쳐 라이브로 진행되고 31일 까지 개최됩니다.\naws summit online japan\n필자는 라이브로 진행되는 양일간에 걸쳐 참가하였으며, 각 내용을 정리해 볼까 합니다.\n1일차 전반적으로 데이터베이스와 AI에 대한 이야기를 들을 수 있었습니다.\n기조강연 테크놀로지가 바꾸는 일본사회라는 테마로 시작하여, AWS의 성장과 설명, 오사카 리전의 탄생을 말하면서 진화하는 AWS에 대해 발표가 있었습니다.\n중간중간 AWS를 이용하는 여러 회사의 관계자 분들의 이야기와 함께, AWS를 이용하여 어떠한 식으로 바뀌었고, 어떠한 것을 바꿀 수 있는지 알 수가 있었습니다.\n 클라우드의 진정한 가치는 가치창출에 집중 할 수 있다는 것\n AWS는 위의 목표를 달성하기 위해 변화를 하고 있고, 계속 해 나가겠다는 것을 알 수 있는 시간이였습니다.\n세션 필자는 주로 업무에 관한 세션이나, 흥미를 가지고 있는 기술에 관한 세션에 참가 하였습니다.\nAI와 기계학습을 사용한 비지니스과제의 해결방법 엔지니어라면 모를 수가 없는 AI, 필자도 흥미를 가지고 있는 기술분야이였기에 참가해보았습니다.\nAI는 어떤 것이며 ML, DL에 대해 간략하게 알아본 다음에 비지니스에서 어떠하게 적용할 수 있는지 설명을 들을 수 있었습니다.\nAI와 비지니스를 연결하는 여러 사례를 들어서 발표되었고, 각 개인별로 맞춤 서비스 제공이나 콜 센터의 AI 활용 등, 업무에서 생각해 볼 만한 내용이였습니다.\n당신의 온프레미스DWH, 모던화 하지 않으시겠습니까? DWH라는 단어에 이끌려 해당 세션을 선택하였습니다. 최근 업무에서 DWH에 관한 일을 하다보니 자연스럽게 궁금해지더군요.\n데이터 웨어 하우스나 데이터 레이크 등 모던한 데이터 기반이란 무엇이고, Amazon Redshift에 대한 설명이 있었습니다.\n이후에는 어떠한 방식으로 마이그레이션 하는지 설명이 이어지고 끝나게 되었습니다.\n마이그레이션 하는 방법을 설명하는 부분부터는 꽤 난해한 점이 이었으나, 모던화에 대해 생각해 볼만한 절차라고 생각되는 시간이였습니다.\n기계학습모델의 개발, 학습, 배포 AI의 흥미에 이끌려 선택한 또 다른 세션입니다. AI의 개발은 현재 경험중인 웹 개발과 무엇이 다를지, 공통점이 있을지 궁금하기도 하였습니다.\n기계학습의 워크플로우에 대한 설명과 Amazon SageMaker가 어떤 기능을 제공하고 있고, 어떻게 활용할 수 있는지 알 수 있는 시간이였습니다.\nAmazon CodeGuru ~기계학습에서 실현하는 코드리뷰 자동화와 어플리케이션 퍼포먼스 최적화~ AI로 코드리뷰를 하는 서비스, Amazon CodeGuru에 대한 설명이 있는 세션입니다.\n소프트웨어의 품질을 향상과 민첩한 개발에 대한 필요성을 이야기 하면서, 자연스레 Amazon CodeGuru Reviewer에 대한 설명으로 이어졌습니다.\n코드 리뷰를 AI가 할 수 있다는 것이 놀라웠으나, 현재는 Java와 Python만 지원 중 이라는 점은 아쉽게 다가왔습니다.\n이후, Amazon CodeGuru Profiler에 대한 설명으로 어플리케이션을 가시화 해서 추적할 수 있다는 점이였습니다.\n이 두 서비스를 실무에서 적용해보면 어떻게 될까 생각해보면서 보게 되는 세션이였습니다.\n[기본 AWS 서비스]오늘부터 시작할 수 있다! AWS의 데이터베이스와 최적의 서비스를 고르는 방법 AWS에서 제공하는 데이터베이스 서비스는 어떠한 것이 있고, 각 서비스에 대한 설명이 있었습니다.\n Purpose-built databases\n 각 상황에 알맞는 데이터베이스를 선택해서 사용할 수 있다는 것을 알 수 있는 세션이였습니다.\n서버리스에서 사용하기 쉬운 API를 공개하자 ~만드는 쪽과 사용하는 쪽에 Circle CI가 제공하는 가치~ 해당 세션은 CircleCI합동회사의 관계자로 부터의 발표였습니다.\nCircleCI는 일본에서 알려져있는 CI 서비스이기도 하고, 어느정도 업무에 관련된 내용도 있을 듯 하여 참가하였습니다.\n주로 CircleCI의 설명과 사용법이 있었습니다.\nBuild modern applications with purpose-built databases 이전 세션에서 들었던 purpose-built databases 에 대해 더 궁금해져서 참가하였습니다.\n모던 어플리케이션이랑 Microservices에 대한 설명과 purpose-built databases가 왜 필요한지, 그리고 여러 회사에서 어떻게 사용하고 있는지 발표가 있었습니다.\n데이터베이스를 필요성에 따라 나누어서 사용하는 것이 막연한 감도 없지 않았지만, 설계를 해나감에 있어서 생각해 나갈 필요성은 충분해 보였습니다.\n서버를 켜두는 것도 아깝다! 서버리스만으로 구축하는 중빈도\u0026amp;단시간 배치 처리 1일차 마지막 세션입니다. 거의 쉬지 않고 계속 들어온 탓에 지쳐있는 필자였지만, 서버리스를 지나칠 수 가 없더군요.\n해당 세션은 주식회사YUMEMI 관계자 분으로 부터의 발표였습니다.\nAWS ECS나 AWS Lambda로 만들었을 때의 해결하고 싶은 부분을 이야기 하면서, AWS Step Functions을 사용한 경험을 들을 수 있었습니다.\n무엇보다 요금이 저렴해 졌다는\u0026hellip; 인상깊은 이야기였습니다.\n1일차 후기 온라인 참가 형식이라 집에서 편히 참가 할 수 있었습니다. AI가 화제되고 있는 점은 여전하다는 것을 느낄 수 있었으며, CodeGuru나 purpose-built databases등 꽤나 흥미로운 이야깃 거리가 있었습니다.\n그와 동시에 듣는 것만으로도 꽤나 지친다는 점을 깨달아 가며, 세월 흐름을 깨달아 가는 건가를 느낄 수 있는 시간이였습니다.\n다음 기사에서는 2일차에 관한 이야기를 올려보고자 합니다.\n","ref":"/posts/2021-05-16-aws-summit-online-day1/"},{"title":"GitHub Universe 2020 후기","date":"","description":"","body":"2020년 12월 9일, 평소와 다를 바 없이 YouTube를 들락거리던 필자는 알 수 없는 YouTube의 알고리즘에 의해 GitHub Universe 2020을 목격합니다.\n개발자라면 모를리 없는 GitHub\u0026hellip; 커서가 이끌려 가는건 어찌보면 본능이였다고 생각되네요. (YouTube알고리즘님 감사합니다.)\n그곳에는 하나의 URL과 무언가 특이한 영상이 나오고 있었으며, URL을 클릭하였더니 개발자스러운 검은 배경의 홈페이지가 등장합니다.\nGitHub Universe 2020\n3일간 온라인으로 중계되며, 4개의 각각 다른 테마로 진행하더군요.\n Developer, Enterprise, Play 그리고 Univers(ity)\n 각각의 테마별로 시간대별 세션이 있고, 그 시간에는 해당 주제에 대한 영상을 볼 수 있게 되어있습니다.\n그리고 필자는 마음이 시키는대로 Developer를 클릭하였습니다.\n대기 시작하기에 앞서, 시간이 될때까지 미리 들어온 사람들에게 영상을 틀어주는데, 이게 좀 특이하더군요.\n 코딩으로 디제잉을 합니다.\n 개발자는 놀때도 코딩으로 놀아줘야 제맛\u0026hellip;인거겠죠!\n보지 못한 분들을 위해서라도 다시 볼 수 있었으면 좋겠네요.\n진행 먼저, 메인 진행자 두분이서 이번 세션에 대해 이야기를 시작합니다.\n그러다가 자연스레 세션 진행자가 참가하게 되고, 발표를 시작하더군요.\n다들 화상회의식으로 참가하시고, 원활하게 진행이되는게 놀라웠네요.\n 영어 실력이 늘었으면 하는 소원을 가진 필자로써는, 발표 화면 덕분에 살았습니다.\n멋진 발표 자료, 감사합니다.\n 마무리로 여러 질문들에 대한 답변의 시간을 가지고, 다음 세션으로 넘어가는 흐름이였습니다.\n후기 다양한 분들이 여러 주제를 가지고 이야기를 주고 받는 모습을 보면서, 시간이 금방 지나가더군요.\n어려운 주제도 많았지만, 새로운 것을 알게되는 자리였네요.\n발표 영상은 다시 볼 수 있게 하는 것 같으니, 못 보신 분들은 한번 봐 보실 수도 있을 것 같습니다.\n GitHub Universe 2020 On-Demand\nhttps://githubuniverse.com/on-demand/\n 다음에 또 있을지도 모르는 즐길거리를 기다리고 있는것도, 재미있을거 같네요.\n심심할때마다 Play 채널도 봤었는데, 정말 즐기는 느낌이 드는 인상깊은 이벤트였습니다.\n","ref":"/posts/2020-12-11-githubuniverse2020/"},{"title":"GitHub Actions으로 GitHub Pages에 배포하기","date":"","description":"GitHub Actions을 이용하여 GitHub Pages에 블로그 사이트를 배포하였습니다.","body":"GitHub Pages도 사용해서 블로그 사이트를 서비스하기로 하였습니다. 이전까지 사용하던 GitHub Pages를 버리기는 아까운 생각이 들더군요.\nGitHub Pages는 기본적으로 jekyll 소스를 자동으로 빌드해서 배포하는 서비스 이지만, 정적 웹 페이지를 그대로 서비스하는 것도 가능합니다.\n그렇기에, Hugo로 만든 블로그라고 할지라도 GitHub Pages에서 서비스가 가능합니다.\n빌드 결과물을 배포하면 되는 단순한 작업이라서 GitHub Actions로 자동으로 하도록 하였습니다. 이 글에서는 그 방법을 적어보려고 합니다.\nGitHub Actions이란?  Automate your workflow from idea to production\nGitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want.\nhttps://github.com/features/actions\n 공식 홈페이지의 소개문입니다만, 아이디어에서 생산까지의 작업 흐름을 자동화! 멋지네요.\nGitHub의 모든 이벤트(commit, pull 등) 에서 실행시키는 것이 가능하다고 하는 군요.\n준비   GitHub Pages Repository\n{자신의 GitHub 아이디}.github.io 의 이름의 repository를 만듭니다.\n  정적 블로그 사이트 소스\n위의 repository의 master branch에 넣어둡시다.\n  만들기 GitHub Actions 소스 다음 파일을 repository의 /.github/workflows 넣어두면 됩니다.\n # This is a basic workflow to help you get started with Actions name: CI # Controls when the action will run. Triggers the workflow on push or pull request # events but only for the master branch on: push: branches: [ master ] # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called \u0026#34;build\u0026#34; build: # The type of runner that the job will run on runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.74.3\u0026#39; # extended: true - name: Build hugo run: hugo --gc --minify - name: Git init run: | git config --global user.name \u0026#39;${{github.actor}}\u0026#39; git config --global user.email \u0026#39;${{github.actor}}@users.noreply.github.com\u0026#39; - name: Git add run: git add --force public/ - name: Git commit run: git commit -m \u0026#34;publish\u0026#34; - name: Push public to branch run: | git subtree split --branch public --prefix public/ git push -f origin public:public git branch -D public https://github.com/DuiNaru/duinaru.github.io/blob/master/.github/workflows/main.yml\n 그러면, master branch에 push가 있을 때 마다 위의 코드가 자동 실행되어서 빌드 결과인 public 폴더의 내용을 전부 public branch에 push하게 됩니다. 강제로 push하기 때문에, 혹시 public이라는 branch를 사용하신다면 Push public to branch에서 \u0026ndash;branch 부분과 public:public 부분을 다른 branch로 바꿔주세요.\n또한, 0.74.3 버전의 Hugo를 사용하였기에 Setup Hugo에서 Hugo를 설치하고, Build Hugo에서 Hugo로 빌드, Git add 및 Push public to branch에서 빌드된 public 폴더를 배포 대상으로 하였지만, 다른 정적 사이트 생성기를 사용하신다면 이 부분을 알맞게 바꿔주시면 됩니다.\nHugo를 extended 버전을 사용할 경우에 해당 주석을 해제하시면 됩니다.\nRepository 설정 repository의 Settings에서 GitHub Pages의 Source Branch를 설정해줍니다.\nGitHub Actions에서 public이라는 branch로 배포하게 해두었기 때문에, pubilc을 source branch로 지정하였습니다.\n끝 push 이벤트가 발생하고 잠시 기다리면, GitHub Pages에 블로그 사이트가 서비스 되고 있을 것입니다.\n필자가 사용하고 있는 Netlify CMS는 글을 작성할때마다 Pull Request가 발생하게 되어, master branch에 push하게 됩니다. 그 때마다, GitHub Actions이 실행되어 자동으로 배포 되기에 Netlify와 동일한 느낌으로 GitHub Pages로 서비스 할 수 있게 되었습니다.\n이번에는 빌드-배포만 있는 정적 사이트라서 간단하지만, 추후에 구체적인 설정까지 사용하게 될 경우에는 어떻게 할 지 생각해봐야 할 듯합니다.\n","ref":"/posts/2020-09-11-deloy-github-pages-with-actions/"},{"title":"Netlify CMS + Netlify 로 블로그 사이트 관리 및 배포 자동화 하기","date":"","description":"","body":"정적 사이트 생성기로 만든 블로그는 markdown형식의 파일로 글을 관리하고 매번 빌드해서 배포 해주어야 하죠. 이를 쉽게 하기위해 Netlify CMS 와 Netlify 를 넣어보았습니다.\nNetlify CMS Netlify CMS, Forestry.io와 같이 정적 사이트의 cms는 여러 가지가 있죠.\nFrontend Interfaces with Hugo\n어떤 서비스라도 관리를 쉽게 해주지만, Netlify 랑 같이 쓰면 좋을 거 같은 Netlify CMS를 적용해 보았습니다.\n특징 netlify cms - overview\n웹 베이스, 많은 정적 사이트 생성기와 같이 사용할 수 있는 등의 좋은 특징이 많습니다.\n가장 큰 특징이라하면 Git을 베이스로 관리한 다는 점이라고 생각되네요. 글 작성하면 commit이 되고, 작성 완료하면 pull request가 되고, 완료한 글을 다시 수정하려면 새로 commit이 되는 것인데, 개발하고 똑같네요. 글 작성 완료하기 전까지 branch를 따로 만들어서 관리할 수도 있습니다.\n설치 템플릿에서 시작하기 netlify cms - Start with a Template\n가장 빠르게 시작할 수 있는 방법입니다. hugo와 같은 정적 사이트 생성기로 사이트를 만들어 둘 필요도 없고, 모든 설정이 완료 되어 있는 템플릿에서 블로그 사이트를 시작하는 것이지요.\n새로 시작하려는 분이나 일단 뭔지 보고 싶다 하시는 분에게 추천드립니다.\n기존 사이트에 추가하기 netlify cms - Add to Your Site\n이미 운영하고 있는 블로그 사이트가 있거나, 처음부터 설정해 나가고 싶으시면 직접 설치 할 수 있습니다.\n다운로드나 설정도 간단하니 쉽게 할 수 있습니다.\n파일 생성 관리 페이지 파일과 설정 파일을 만들어 주어야 합니다. 파일의 위치는 다음과 같습니다.\n    These generators \u0026hellip; store static files in     Jekyll, GitBook / (project root)   Hugo, Gatsby, Nuxt, Gridsome, Zola, Sapper /static   Next /public   Hexo, Middleman, Jigsaw /source   Spike /views   Wyam /input   Pelican /content   VuePress /.vuepress/public   Elmstatic /_site   11ty /_site   preact-cli /src/static    https://www.netlifycms.org/docs/add-to-your-site/#app-file-structure\n 정적 사이트 생성기 별로 빌드할 때, 웹 페이지가 그대로 배포되는 위치입니다. hugo로 만든 블로그 사이트에 배포 할 것이니 static 폴더 에 만들어 주면 되겠네요.\n해당 폴더에 admin이라는 폴더를 만들고 다음 파일 2개를 만들어 줍시다.\n index.html\n\u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Content Manager\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- Include the script that builds the page and powers Netlify CMS --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/netlify-cms@^2.0.0/dist/netlify-cms.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://identity.netlify.com/v1/netlify-identity-widget.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; if (window.netlifyIdentity) { window.netlifyIdentity.on(\u0026#34;init\u0026#34;, user =\u0026gt; { if (!user) { window.netlifyIdentity.on(\u0026#34;login\u0026#34;, () =\u0026gt; { document.location.href = \u0026#34;/admin/\u0026#34;; }); } }); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; config.yml\nbackend: name: git-gateway branch: master # Branch to update (optional; defaults to master) # This line should *not* be indented publish_mode: editorial_workflow # These lines should *not* be indented media_folder: \u0026#34;/static/img/uploads\u0026#34; # Media files will be stored in the repo under static/images/uploads public_folder: \u0026#34;/img/uploads\u0026#34; # The src attribute for uploaded media will begin with /images/uploads collections: - name: \u0026#34;blog\u0026#34; # Used in routes, e.g., /admin/collections/blog label: \u0026#34;Blog\u0026#34; # Used in the UI folder: \u0026#34;_posts/blog\u0026#34; # The path to the folder where the documents are stored create: true # Allow users to create new documents in this collection slug: \u0026#34;{{year}}-{{month}}-{{day}}-{{slug}}\u0026#34; # Filename template, e.g., YYYY-MM-DD-title.md fields: # The fields for each document, usually in front matter - {label: \u0026#34;Layout\u0026#34;, name: \u0026#34;layout\u0026#34;, widget: \u0026#34;hidden\u0026#34;, default: \u0026#34;blog\u0026#34;} - {label: \u0026#34;Title\u0026#34;, name: \u0026#34;title\u0026#34;, widget: \u0026#34;string\u0026#34;} - {label: \u0026#34;Publish Date\u0026#34;, name: \u0026#34;date\u0026#34;, widget: \u0026#34;datetime\u0026#34;} - {label: \u0026#34;Featured Image\u0026#34;, name: \u0026#34;thumbnail\u0026#34;, widget: \u0026#34;image\u0026#34;} - {label: \u0026#34;Rating (scale of 1-5)\u0026#34;, name: \u0026#34;rating\u0026#34;, widget: \u0026#34;number\u0026#34;} - {label: \u0026#34;Body\u0026#34;, name: \u0026#34;body\u0026#34;, widget: \u0026#34;markdown\u0026#34;} https://www.netlifycms.org/docs/add-to-your-site/#configuration\n index.html은 Netlfiy CMS에 접속하기 한 페이지이고, config.yml은 설정 파일입니다.\n이 이외도 여러 설정이 있으니, 공식 홈페이지에서 찾아볼 수 있습니다.\n확인 netlfiy cms 페이지를 확인해 봅시다.\nhugo -serve 로 구동 후, http://localhost:1313/admin 에 접속하면 로그인 화면이 나올 것 입니다.\nNetlify 설정 파일 생성 이후부터는 Netlify에 배포하고 사용하게 됩니다. 그러기 위해서 블로그 사이트 경로에 netlify.toml 파일을 작성해줍니다. 해당 파일은 Netlify 설정파일로써, 빌드 명령어나 환경 변수 등을 지정할 수 있습니다.\n#/my-blog/netlify.toml [build] publish = \u0026#34;public\u0026#34; command = \u0026#34;hugo --gc --minify\u0026#34; [context.production.environment] HUGO_VERSION = \u0026#34;0.74.3\u0026#34; HUGO_ENV = \u0026#34;production\u0026#34; HUGO_ENABLEGITINFO = \u0026#34;true\u0026#34; [context.split1] command = \u0026#34;hugo --gc --minify --enableGitInfo\u0026#34; [context.split1.environment] HUGO_VERSION = \u0026#34;0.74.3\u0026#34; HUGO_ENV = \u0026#34;production\u0026#34; [context.deploy-preview] command = \u0026#34;hugo --gc --minify --buildFuture -b $DEPLOY_PRIME_URL\u0026#34; [context.deploy-preview.environment] HUGO_VERSION = \u0026#34;0.74.3\u0026#34; [context.branch-deploy] command = \u0026#34;hugo --gc --minify -b $DEPLOY_PRIME_URL\u0026#34; [context.branch-deploy.environment] HUGO_VERSION = \u0026#34;0.74.3\u0026#34; [context.next.environment] HUGO_ENABLEGITINFO = \u0026#34;true\u0026#34; Repository 생성 Netlify에 배포하기 위해 GitHub, GitLab, Bitbucket  중 하나에 지금까지 작성한 블로그 사이트 Repository를 만들어서 Push해줍니다.\nNetlify Netlify 배포 ﻿로그인 Netlify에 접속해서 로그인을 합니다.\nhttps://www.netlify.com/\n이후, New site from Git 으로 사이트를 생성합니다. 처음 계정을 생성하신 분이라면, 바로 사이트 생성화면이 나올 수도 있습니다.\n사이트 생성 Repository를 만든 Git을 연결해줍니다.\n그러고 나면 Repository를 선택하는 화면이 나올텐데, 블로그 사이트 Repository를 선택해 줍니다.\n이제, Branch와 빌드 명령어를 설정해주면 끝납니다.\nDeploy site버튼을 눌러서 Site를 생성해줍니다.\nHugo Future Imperfect Slim를 clone으로 넣었더니, 화면처럼 Failed로 실패라고 나왔습니다. submodule로 넣은 경우에는 나오지 않을 것입니다.\nSubmodule Path가 없다는 에러여서 .gitmodules 파일을 블로그 사이트 경로에 만들고, Push해주었습니다.\n .gitmodules\n[submodule \u0026quot;hugo-future-imperfect-slim\u0026quot;] path = themes/hugo-future-imperfect-slim url = https://github.com/pacollins/hugo-future-imperfect-slim.git  생성 확인 성공하면 다음처럼 Published를 확인 할 수 있습니다.\n사이트 확인 화면에 표시된 URL에 접속하면 블로그 사이트를 확인 할 수 있습니다.\nNetlify 설정 이제 Netlify CMS를 사용하기 위해 Netlify에서 로그인 관련 설정을 해 줄 것입니다.\nIdentity 메뉴에서 Identity을 활성해 줍니다. 이 기능을 사용함으로써, 가입 등의 인증 관련 기능을 사용 할 수 있습니다.\nEnable Git Gateway Netlify CMS 에서 Git 을 처리하기 위해 사용 설정을 해 줍니다. Settings - Identity 메뉴에 Services - Git Gateway 에 있는 Enable Git Gateway 버튼을 클릭합니다.\n초대 전용으로 설정 Settings - Identity - Registration 에서 Edit 버튼을 눌러서 Invite only로 바꿔줍시다. 이 설정으로 누구나 아이디를 생성할 수 없게 됩니다.\n아이디 추가 이제 아이디를 추가해 줄 것입니다.\nInvite users를 클릭하여, 이메일을 적어주고 Send를 눌러줍시다.\n해당 이메일로 인증메일이 도착해 있을 것입니다. Accept the invite 를 클릭하면 블로그 사이트로 이동됩니다.\nURL이 아래와 비슷할텐데, 중간에 admin을 넣어서 CMS 페이지로 바꿔 줍니다.\n변경 전\nhttps://trusting-curran-e13b73.netlify.app/#invite_token=-W5a_7Eao-GCIMVEpr97Vw\n변경 후\nhttps://trusting-curran-e13b73.netlify.app/admin#invite_token=-W5a_7Eao-GCIMVEpr97Vw\n그러면, 비밀번호를 설정하는 화면이 나옵니다.\n확인 비밀번호를 설정하고 나면 자동으로 로그인이 되고 아래와 같은 페이지가 나옵니다.\n이제 New Blog 를 눌러서 글을 쓰는 등의 Netlify CMS를 사용 할 수 있게 되었습니다.\n후기 글을 쓰다보니 꽤 길어졌네요. Netlify CMS를 설정해두면 웹에서 바로 글을 작성할 수 있어서 편합니다.\n그러나, 한국어나 일본어 작성이 중간중간 씹히는 현상이 생기는 군요. 영어는 문제 없는 걸로 보아 CMS 스크립트가 영어 위주로 생각해서 만들어 진 모양입니다.\n이미지 업로드는 편해서 만족하는데, 글 씹히는 건 천천히 해결해 봐야 겠네요.\n","ref":"/posts/2020-09-02-make-blog-with-netlifycms-netlify/"},{"title":"Hugo로 블로그 만들기","date":"","description":"","body":"Hugo를 사용하여 블로그를 만들어 보았습니다. Hugo를 설치하고 테마를 적용하는 것만으로도 바로 만들 수 있습니다.\nHugo 설치 우선 Hugo를 설치해 주어야 합니다.\nInstall Hugo\nHugo는 기본 버전과 extended버전이 있습니다. extended버전은 SCSS/SASS를 지원하는 버전으로, SCSS/SASS를 사용하고자 하실 분은 extended버전으로 설치해야 한다고 하네요.\n And Now: Hugo Pipes!\nHugo is now released with two binary version: One with and one without SCSS/SASS support. At the time of writing, this is only available in the binaries on the GitHub release page. Brew, Snap builds etc. will come. But note that you only need the extended version if you want to edit SCSS. For your CI server, or if you don’t use SCSS, you will most likely want the non-extended version.\n 이번 글에서 사용할 테마가 SCSS를 사용하는 듯 하여, extended버전을 설치하겠습니다.\n패키지 매니저 설치 Windows환경에 설치할 생각이라 chocolatey를 이용해서 설치해 주었습니다. 다른 환경에 설치 할 생각이시라면, Install Hugo 을 참고해주세요.\n Installing Chocolatey\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;))  관리자 권한으로 Powershell에 해당 명령어를 실행시키면 됩니다. 보안 설정이 있을 수 있으니 Bypass 설정을 한다는 군요.\nchoco나 choco -?로 설치된 것을 확인하였으면, Hugo를 설치하면 됩니다.\nHugo 설치  Install Hugo - Chocolatey (Windows)\nchoco install hugo-extended -confirm  hugo version으로 설치된 것을 확인 할 수 있습니다. 0.74.3버전이 설치되었네요.\nHugo Static Site Generator v0.74.3/extended windows/amd64 블로그 생성 블로그를 만들 디렉토리에서 다음 명령어를 실행하면 끝납니다. new-site-name은 원하는 폴더 이름을 넣어주시면 됩니다.\nhugo new site new-site-name 지정한 이름의 하위 디렉토리가 생기고, hugo 폴더 구조로 만들어 진것을 확인 할 수 있습니다.\n빌드 해당 폴더에서 hugo명령어를 실행시키면 public 폴더가 생기고, 빌드된 파일이 안에 들어있게 됩니다.\nhugo | EN -------------------+----- Pages | 3 Paginator pages | 0 Non-page files | 0 Static files | 0 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 실행 그리고 hugo serve 로 로컬 환경에서 블로그 사이트에 접속 해 볼수 있습니다.\nhugo serve | EN -------------------+----- Pages | 3 Paginator pages | 0 Non-page files | 0 Static files | 0 Processed images | 0 Aliases | 0 Sitemaps | 1 Cleaned | 0 Built in 6 ms Watching for changes in C:\\Hugo\\Sites\\my-blog\\{archetypes,content,data,layouts,static} Watching for config changes in C:\\Hugo\\Sites\\my-blog\\config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop http://localhost:1313/ 로 접속하면 빈 화면이 나오는 것을 확인 할 수 있을 것입니다.\n테마 설치 빈 화면에서 만들어 나갈 수도 있지만, 이미 만들어진 여러 테마들이 있습니다.\nHugo Themes\n테마 중에 하나 선택하여 적용 해 보겠습니다.\n다운로드 Hugo Future Imperfect Slim\nHugo Future Imperfect Slim라는 테마를 다운로드 하였습니다. 다운로드한 테마는 블로그 사이트 폴더 안의 themes 폴더 안에 넣어주면 됩니다.\ncd C:\\Hugo\\Sites\\my-blog\\themes git clone https://github.com/pacollins/hugo-future-imperfect-slim.git 다른 테마라도, themes 폴더 안 에 넣어주면 됩니다.\n이제, 테마 설정을 하면 블로그 완성입니다.\n설정 테마 설정은 테마별로 각각 다르나, 모든 설정은 블로그 사이트 폴더 안의 config.toml 의 파일에 설정하게 됩니다. 해당 파일은 hugo의 설정 파일로, 블로그 사이트의 타이틀이나 사용할 테마 등을 설정할 수 있습니다.\n필자는 Hugo Future Imperfect Slim 를 사용하였기에, 아래와 같이 설정해주었습니다.\n Hugo Future Imperfect Slim - config.toml\nbaseurl = \u0026#34;\u0026#34; DefaultContentLanguage = \u0026#34;en\u0026#34; title = \u0026#34;Hugo Future Imperfect Slim\u0026#34; theme = \u0026#34;hugo-future-imperfect-slim\u0026#34; paginate = 3 disqusShortname = \u0026#34;\u0026#34; googleAnalytics = \u0026#34;\u0026#34; pluralizeListTitles = false disableLanguages = [] [markup.goldmark.renderer] unsafe = true [outputs] home = [\u0026#34;html\u0026#34;, \u0026#34;json\u0026#34;] [params] enableCDN = false cssFiles = [\u0026#34;default\u0026#34;] jsFiles = [\u0026#34;default\u0026#34;] highlightjs = true highlightjsTheme = \u0026#34;default\u0026#34; highlightjsLang = [] viewMorePostsLink = \u0026#34;/blog/\u0026#34; readingTime = true imageStrech = \u0026#34;\u0026#34; socialShare = [\u0026#34;twitter\u0026#34;, \u0026#34;facebook\u0026#34;, \u0026#34;reddit\u0026#34;, \u0026#34;linkedin\u0026#34;, \u0026#34;pinterest\u0026#34;, \u0026#34;email\u0026#34;] [params.meta] description = \u0026#34;A theme by HTML5 UP, ported by Julio Pescador. Slimmed and enhanced by Patrick Collins. Multilingual by StatnMap. Powered by Hugo.\u0026#34; author = \u0026#34;HTML5UP and Hugo\u0026#34; favicon = false svg = true faviconVersion = \u0026#34;1\u0026#34; msColor = \u0026#34;#ffffff\u0026#34; iOSColor = \u0026#34;#ffffff\u0026#34; [params.header] navbarTitle = \u0026#34;Future Imperfect\u0026#34; dynamicTitles = true searchMenu = true shareMenu = true languageMenu = true [params.intro] header = \u0026#34;Hugo Future Imperfect Slim\u0026#34; paragraph = \u0026#34;Another fine, responsive site template by \u0026lt;a href=\u0026#39;http://html5up.net\u0026#39;\u0026gt;HTML5 UP\u0026lt;/a\u0026gt;.\u0026#34; rssIntro = true socialIntro = true hideWhenSingleColumn = false alwaysOnHomepage = false [params.intro.pic] src = \u0026#34;/img/main/logo.jpg\u0026#34; shape = \u0026#34;circle\u0026#34; width = \u0026#34;\u0026#34; alt = \u0026#34;Hugo Future Imperfect Slim\u0026#34; [params.sidebar] about = \u0026#34;This theme was developed for Hugo static site generator.\u0026#34; postAmount = 5 categories = true categoriesByCount = true [params.footer] rssFooter = true socialFooter = true [params.staticman] enabled = false api = \u0026#34;\u0026#34; # No Trailing Slash gitProvider = \u0026#34;github\u0026#34; username = \u0026#34;\u0026#34; repo = \u0026#34;\u0026#34; branch = \u0026#34;\u0026#34; [params.staticman.recaptcha] siteKey = \u0026#34;\u0026#34; encryptedKey = \u0026#34;\u0026#34; [menu] [[menu.main]] name = \u0026#34;Home\u0026#34; identifier = \u0026#34;home\u0026#34; url = \u0026#34;/\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-home\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; weight = 1 [[menu.main]] name = \u0026#34;About\u0026#34; identifier = \u0026#34;about\u0026#34; url = \u0026#34;/about/\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;far fa-id-card\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; weight = 2 [Languages] [Languages.en] LanguageCode = \u0026#34;en\u0026#34; LanguageName = \u0026#34;English\u0026#34; weight = 1 [Languages.fr] LanguageCode = \u0026#34;fr\u0026#34; LanguageName = \u0026#34;Français\u0026#34; title = \u0026#34;Hugo Future Imperfect Slim en français\u0026#34; description = \u0026#34;Un thème par HTML5 UP, porté par Julio Pescador. Simplifié et amélioré par Patrick Collins. Multilingue par StatnMap. Propulsé par Hugo.\u0026#34; weight = 2 [[Languages.fr.menu.main]] name = \u0026#34;Accueil\u0026#34; identifier = \u0026#34;home\u0026#34; url = \u0026#34;/\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-home\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; weight = 1 [social] # Coding Communities github = \u0026#34;pacollins/hugo-future-imperfect-slim\u0026#34; gitlab = \u0026#34;\u0026#34; stackoverflow = \u0026#34;\u0026#34; # User Number bitbucket = \u0026#34;\u0026#34;  확인 필요한 설정을 해주고, 다시 hugo serve를 실행 시켜서 http://localhost:1313/ 에 접속해 봅시다.\n테마가 적용된 것을 확인 할 수 있습니다. 다만, 아무 글도 없으니 허전하네요. 글 하나 작성해봅시다.\n글 작성 아래 처럼 만들면 됩니다. 해당 파일은 markdown형식의 파일이며, 글 하나에 해당합니다.\nhugo new posts/new-post.md content/posts의 폴더 안에 new-post.md파일이 만들어 진 것을 확인 할 수 있습니다. 파일은 hugo new 명령어도 만들어도 되고, 직접 만들어도 됩니다. 명령어로 만들 경우, draft 설정으로 만들어 지므로 확인하기 위해서는 다음 명령어로 실행합니다.\nhugo serve -D http://localhost:1313/ 에 접속하면 글이 하나 생긴 것을 확인 할 수 있습니다.\n새로 생긴 파일에 내용을 적음으로써 블로그 글을 작성할 수 있게 됩니다.\n그러나, 파일 하나하나를 직접 수정하고 관리하는 것은 불편함이 따르기 마련입니다. 그래서 다음에는 글을 작성하거나 관리하는 것을 보다 편하게 하기 위해 CMS을 설정하는 글을 적어보려 합니다.\n","ref":"/posts/2020-08-23-blog-with-hugo/"},{"title":"블로그를 리뉴얼 하였습니다","date":"","description":"Github Pages + Jekyll 에서 Netlify + Hugo + Netlify CMS 로 블로그를 리뉴얼 하였습니다.","body":"기존에는 Jekyll로 만들어서 Github Pages에 배포하였지만, Jekyll의 다국어 지원이 불편해서 고민하던 중에 Hugo 로 바꾸어 쓰기로 하였습니다. 그러면서 Netlify + Netlify CMS 을 넣어보기로 하고요.\n이 글에서는 리뉴얼 후기 및 과정에 대해 적어볼까 합니다.\nHugo Hugo는 go 언어로 작성된 정적 사이트 생성기 입니다. 일반적인 동적 사이트 처럼 서버에서 웹 페이지를 만들어서 보여주는 것과 다르게 단순히 만들어져 있는 웹 페이지를 보여주게 되죠. 서버 자원을 절약할 수 있다는 점이 매력적인 부분입니다.\nJekyll 역시 정적 사이트 생성기 이지만, 비교적 최신이기도 하고 다국어 지원에서의 편리함도 있어서 바꾸기로 하였습니다.\n다국어 지원 - Jekyll vs Hugo Jekyll Jekyll에서의 다국어 지원은 주로 plugin을 통해서 지원합니다.\n개발과 경험이 함께 하는 블로그 - 만들기\npolyglot 이나 jekyll-multiple-languages-plugin 이 대표적이지만, 둘다 플러그인 이기에 다른 플러그인과 함께 쓰거나 관리에 있어 불편함이 생기기 마련이죠.\n아니면 플러그인을 사용하지 않고 Jekyll 의 코드를 직접 작성해서 만들어도 되지만, 불편함은 여전하죠.\nHugo 그에 반해 Hugo 는 다국어를 지원합니다.\nHugo - Multilingual Mode\n기본적으로 지원하고 있기에, 편리할 것으로 보여서 사용하기로 하였습니다.\nNetlify CI/CD 도구 중에 하나로, 배포까지 자동화 할 수 있게 되죠.\nNetlify CMS에서 글을 작성하게 되면, Git repository에 추가 되는데, 즉시 Hugo를 사용하여 빌드를 하고, 웹에서 볼 수 있게 할 수 있습니다. 글 작성할 마다 수동으로 빌드해주고 배포할 필요가 없어지게 되죠.\nNetlify CMS 기존에는 jekyll-admin 플러그인으로 글을 관리 했었으나, hugo로 바꾸면서 다른 방법을 찾아야 했습니다.\nFrontend Interfaces with Hugo\n그 중에 Netlify랑 같이 쓰기 좋아보이는 Netlify CMS 를 넣어봤습니다.\n글 작성이나 수정, 삭제를 Git으로 관리 할 수 있어서, Git의 장점을 같이 누릴 수 있게 됩니다. 작성한 글들의 목록을 확인하거나, 작성하면서 미리보기 등의 기능도 편리하지요.\nTheme 여러가지의 테마 중에 Hugo Future Imperfect Slim 를 사용하였습니다.\nHugo Future Imperfect Slim\n깔끔하니 좋은 듯 합니다. 게다가 계속 업데이트가 이루어 지고 있으니, 문제가 생기더라도 대처가 빠를 듯 하네요.\n완성 https://duinaru.netlify.app/\n도메인은 따로 설정해 주지는 않고, netlify에서 기본 설정된 도메인을 사용하고 있습니다. 도메인을 변경하게 되더라도, Netlify에 도메인 추가 설정만 해주면 되기에 천천히 생각해 보려고 합니다.\n다음에는 만드는 과정이나 고민한 것에 대해서 글을 작성해볼까 합니다.\n","ref":"/posts/2020-08-22-blog-renewal/"},{"title":"CloudWatch를 이용하여 일정 시간 동안 SSH 연결이 없을 때, EC2 자동 종료 시키기","date":"","description":"","body":"주로 Cloud9로 사용하는 EC2가 SSH 연결이 없을 때는 사용할 일이 없어서, 일정 시간 대기 한 뒤에 자동 종료가 되도록 만들어 보았습니다.\nEC2에서 실행되는 스크립트 만으로도 가능할 듯 하지만, AWS에서 SSH의 연결 수도 모니터링할 수 있게 하도록 CloudWatch를 이용하였습니다.\nIAM User 작성 CloudWatch로 SSH의 연결 수를 보내는 역할을 하는 User가 필요합니다.\naws cli에서 접속이 가능하고 권한은 CloudWatchAgentServerPolicy을 가진 User를 생성하였습니다.\n  EC2에 aws cli 설정 CloudWatch로 SSH의 연결 수를 보내기 위해서 EC2에 aws cli를 설치하고, 위에서 만든 User를 설정해줍니다.\n설치 aws cli를 설치해줍니다.\nInstall the AWS CLI version 1 on Linux\nUser 설정 방금 만든 User로 설정해줍니다.\nConfiguring the AWS CLI\nSSH 연결 수 알아내기 현재 연결된 SSH의 수를 알아낼 수 있어야 CloudWatch로 보낼 수 있을 것입니다.\n연결 되어 있는 사용자를 알아내는 방법 who 해당 명령어로 현재 접속되어 있는 사용자를 알아 낼 수 있습니다.\nSSH로 접속했을 경우, 아래와 같이 확인할 수 있습니다.\n  다만, Cloud9로 접속했을 경우에는 아무것도 나오지 않는 것을 확인 할 수 있습니다.\n  Cloud9의 연결은 확인 되지 않음 왜 일까요?\nCloud9의 SSH Host Requirements을 보면 SSH 접속 가능이 요구되어 있어서 SSH를 이용하는 것은 알 수가 있습니다.\n현재 실행 중인 SSHD의 갯수로 알아내기 SSH로 연결은 하는 것 같으니까, 실행 중인 SSHD를 알아봅시다.\nps -A x | grep \u0026quot;sshd\u0026quot;   sshd: ubuntu [priv]과 sshd: ubuntu@notty이 각각 2개씩, 총 4개가 보이네요.\nSSH로 접속할 때 보안 강화의 방법으로 priv 로 프로세스를 만든다음, 자식 프로세스를 만들어서 처리시킨다고 하네요.\n UsePrivilegeSeparation\n 그래서 한 개의 SSH 접속에 2개의 프로세스가 만들어 지나 봅니다.\n그럼 현재 2개의 SSH 연결이 있다는 것을 알 수 있네요.\n다음 명령으로 SSH 연결 수를 알아냅니다.\nps -A x | grep \u0026quot;sshd\u0026quot; | grep \u0026quot;\\\\[priv\\\\]\u0026quot; | wc -l   SSH 연결 수 전송 알아낸 SSH 연결 수를 CloudWatch에 전송하도록 합니다.\nput-metric-data --namespace \u0026lt;value\u0026gt; --dimensions \u0026lt;value\u0026gt; --metric-name \u0026lt;value\u0026gt; --value \u0026lt;value\u0026gt; --timestamp \u0026lt;value\u0026gt; ...and more options put-metric-data aws cli를 이용하여 CloudWatch에 Metric을 보내는 명령입니다.\n보낸 데이터를 시간 단위로 기록하게 되고, 시간의 경과에 따른 변화를 살펴 볼 수 있게 됩니다.\n해당 명령어로 위에서 알아낸 SSH의 연결 수를 CloudWatch로 보낼 수 있게 됩니다.\ndemension 보내는 데이터의 상세 정보와 같은 느낌으로 설정할 수 있습니다.\nInstanceId=인스턴스ID로 인스턴스 ID를 설정하였는데, 이는 CloudWatch Alarm에서 인스턴스 종료 명령은 InstanceId가 설정되어 있는 Metric만 가능하였기 때문입니다.\n그렇기 때문에, 자동 종료를 위해서는 InstanceId로 설정해주어야 합니다.\nvalue 보내는 Metric의 값 입니다.\n현재 실행 중인 SSHD의 갯수로 알아내기에서 알아낸 연결 수를 넣어주었습니다.\ntimestamp Metric의 시간을 지정해 줄 수 있습니다.\n보낼 때의 시간을 구해서 UTC 의 형태로 넣어주었습니다.\ncrontab 전송을 일정 주기로 반복 시키기 위해서 사용하였습니다.\n자세한 설명은 이곳을 보면 되고, 아래와 같이 설정합니다.\n반복 수행할 스크립트 작성 /home/ubuntu/ssh-count.sh 으로 다음과 같은 스크립트를 만들었습니다.\n#!/bin/bash SSH_CONNECTIONS=$(ps -A x | grep sshd | grep \\\\[priv\\\\] | wc -l) TIMESTAMP=$(date --utc +%FT%T.%3NZ) /home/ubuntu/.local/bin/aws cloudwatch put-metric-data --metric-name \u0026quot;SSH Connections\u0026quot; --dimensions InstanceId=\u0026quot;인스턴스ID\u0026quot; --namespace \u0026quot;EC2\u0026quot; --value $SSH_CONNECTIONS --timestamp $TIMESTAMP metric-name는 지정 하고 싶은 이름으로, InstanceId는 종료 시키고 싶은 인스턴스의 ID를 넣어줍니다.\ncrontab에 스크립트 등록 crontab -e에 1분 마다 스크립트를 수행하도록 설정하였습니다.\n가장 마지막에 아래 명령을 추가하면 됩니다.\n*/1 * * * * /home/ubuntu/ssh-count.sh 확인 CloudWatch - Metrics 에서 Custom Namespaces 항목의 EC2 - InstanceId 에서 확인 할 수 있습니다.\nEC2 자동 종료 이제 일정 시간 내에 SSH 연결 수가 0이면, EC2를 자동으로 종료되도록 만들어 볼 것입니다.\nCloudWatch Alarm 설정 CloudWatch - Alarms 에서 Create alarm 을 눌러서 Alarm을 만듭니다.\nSpecify metric and conditions 이 화면에서는 사용할 Metric의 선택과 설정을 할 수 있습니다.\nMetric Select Metric 을 눌러서 방금 만든 Metric을 선택하고, Statistic와 Period를 확인합니다.\nPeriod의 기간내의 수집된 Metric을 Statistic에서 설정한 방법대로 통계내서 확인하게 되므로, 1분 간격의 데이터를 전부 보기 위해 Period를 1분으로 설정하였습니다.\nConditions Threshold type는 Static, Whenever는 Lower/Equal, than은 0로 설정해서 값이 0이하이면 Alarm이 되도록 하였습니다.\n  Additional configuration 0이하로 되자마자 Alarm이 되지 않도록 Datapoints to alarm을 설정하였습니다.\n  최근 15갯수내에서 0이하가 15개 이면 Alarm이 되도록 하였습니다. Period를 1분으로 설정했으니, 15분 동안 계속 0이하이면 Alarm이 되는 셈이죠.\nConfigure actions 이 화면에서는 상태에 따라 취할 Action을 설정합니다.\nNotification AWS SNS로 알림을 보낼 생각이 있으면, 설정합니다.\n하지 않을 생각이면, Remove를 눌러주세요.\nEC2 action EC2에 종료 명령을 내릴 수 있게 할 수 있습니다.\n아래처럼 Alarm의 경우에 Stop this instance 을 하도록 설정해 주었습니다.\n  그리고, 나머지는 적당히 입력해서 완성했습니다.\n확인 CloudWatch - Alarms 에서 확인이 가능합니다.\n종료 할 때에는 ALARM, 종료 후 시간이 지나면 INSUFFICIENT, 실행 중일 때에는 OK 로 변하는 것을 볼 수 있을 것입니다.\n한계  매우 짧은 연결  1분 마다 현재 실행중인 SSHD를 세어서 보내기 때문어, 샘플링 주기의 사이에 실행되고 종료되는 SSHD가 있다면, 기록 되지 않을 것입니다.\n이러한 연결이 의미가 있는 연결일 것이라고 생각 되지 않기에, 별 문제는 없어보입니다.\n연결이 될 때 put-metric-data를 실행하도록 하면 해결이 되기도 하죠.\n 연결이 없어도 기다리는 SSHD  사용하지 않고 있더라도 SSHD가 바로 종료되는 것은 아니기에, 정확한 연결 수를 얻어내려면 추가적인 설정이 필요로 할 듯 합니다. ClientAliveInterval이랑 ClientAliveCountMax와 같은 설정으로 말이죠.\n 종료 직전에 SSH 연결  SSH 연결 수를 전송하고 Alarm에서 감지하여 종료되기 사이에 새로운 접속이 있을 경우를 생각해 볼 수 있는데, 접속하자마자 종료가 될 듯하므로, 문제는 없을 듯 합니다.\n소감 Cloud9으로만 사용할 생각이면, Cloud9에서 EC2를 만드는 것이 Cloud9에 맞춰서 자동 종료가 되기에 좋습니다.\n다만, 자동 종료 기능은 Cloud9을 종료하고 일정 시간 뒤에 EC2가 종료 되기 때문에, Cloud9을 종료후에도 사용할 경우가 있다면 자동 종료 기능을 꺼야 하므로 직접 구축한 EC2와 큰 차이가 없게 됩니다.\n또는, EC2를 수동으로 구축한 경우도 생각해볼 수 있습니다.\n이런 경우에도 자동으로 종료 시키는 것은 가능하다는 것을 알았습니다.\n이 글의 방법에서 SSH의 연결 수를 알아내어 전송하는 부분을 변경하면 다른 상황에서도 사용 할 수 있을듯 합니다.\n","ref":"/posts/2019-12-01-stop-ec2-when-no-ssh-connection-for-a-while/"},{"title":"SSM와 CloudWatch로 로그인할 때, EC2가 자동 시작되게 하기","date":"","description":"","body":"Cloud9를 수동으로 만든 EC2로 사용하다보니, 자동으로 만들 때 사용할 수 있는 EC2의 자동 시작-종료 기능을 사용할 수 없어서, 만들어 보기로 했습니다.\n다만, Cloud9이 시작할 때 EC2를 시작 시킬 수 없어서 Console에 Sign in 할 때, 시작 되도록 만들었습니다.\nAWS System Manager EC2를 실행시키기 위해 SSM을 사용할 생각입니다.\n그러기 위해서는 SSM가 EC2를 관리 할 수 있도록 설정을 해야 합니다.\nIAM의 Role 생성 : AmazonSSMManagedInstanceCore EC2를 SSM에서 사용하기 위해서 IAM role을 설정해야 합니다.\nAmazonSSMManagedInstanceCore의 policy를 선택해서 하나 만들어 줍니다.\n  해당 IAM을 자동 시작시키려는 EC2에 붙여 주면 됩니다.\nAttaching an IAM Role to an Instance\n위의 링크처럼 붙여주면 됩니다.\nIAM의 Role 생성 : AmazonSSMAutomationRole 이번에는 SSM을 실행 할 때 필요한 IAM role을 만들어야 합니다.\nAmazonSSMAutomationRole의 policy를 선택해서 만들어 주면 됩니다.\n  다음은 로그인 이벤트가 발생하면 SSM으로 EC2가 시작되도록 설정합니다.\nCloudTrail 설정 로그인 이벤트를 이용하기 위해서는 CloudTrail를 설정할 필요가 있습니다.\nCloudTrail의 왼쪽 메뉴에서 Trails - Create Trail 를 순서대로 눌러줍시다.\n  만들고 설정을 보면 Logging 이 ON 이 되어 있는 것을 확인 할 수 있습니다.\n  설정이 끝났습니다.\nCloudWatch의 Rules설정 로그인 이벤트를 CloudWatch 에서 감지해서 처리하도록 해봅시다.\nCloudWatch의 왼쪽 메뉴에서 Rules - Creates rule 를 순서대로 눌러줍시다.\nEvent Source   Service Name 은 AWS Console Sign-in 을 선택합니다.\n어떤 유저라도 로그인 할 때 처리할 생각이면, Any user을 선택하고,\n특정 유저만 로그인 할 때 처리할 생각이면, Specific users(s) by ARN 을 선택해서 해당 유저의 arn 을 넣어줍시다.\nTargets 로그인 이벤트의 기록과 EC2가 시작되도록 설정합시다.\nCloudWatch log Group에는 Log Group를 적당히 입력하고,\nSSM Automation은 Document를 AWS-StartEC2Instance를 선택, InstanceId에 시작시키고 싶은 인스턴스의 ID를 넣어줍니다.\n그 아래는 Use existing role 을 선택하고 IAM의 Role 생성 : AmazonSSMAutomationRole에서 만든 Role를 지정해줍시다.\n  name을 지정하고 Enabled가 체크된 상태에서 만들면 됩니다.\n확인해보기 제대로 EC2가 실행되는지 확인해 봅시다.\n그러려면 다시 로그인을 해야 겠네요.\n1~2분정도의 시간이 지나니, Targets에서 만든 CloudWatch의 Log Group에 로그인 이벤트가 기록되고, EC2가 기동하고 있었습니다.\n후기 CloudTrail를 설정하지 않아, 로그인 이벤트가 연결 안 된다거나\nSSM Automation의 role를 제대로 설정하지 않아 rule이 실행 되지 않다거나 등등\n이것저것 시행착오를 겪어서 성공하게 되었네요.\nCloud9에서 만들 때 사용가능한 EC2의 자동 시작과 비슷하게 쓸 수 있겠네요.\n다음엔 일정 시간 동안 접속이 없으면 종료되도록 해 볼 생각입니다.\n","ref":"/posts/2019-11-18-auto-start-ec2-on-sign-in/"},{"title":"Rails 화면 띄우기 및 Cloud9 사용","date":"","description":"","body":"샘플 화면 하나를 띄우고, 본격적인 개발에 앞서 IDE를 사용하기로 하였습니다.\nblog 생성 blog라는 이름의 rails 어플을 생성하였습니다.\nrails new blog 해당 명령어로 미리 설정되어 있는 blog 어플리케이션을 가져와서 다운로드한다네요.\n에러 발생 설치는 되었는데, 중간에 에러가 나왔네요. 역시 한번에 되는건 없나봅니다.\nGem::Ext::BuildError: ERROR: Failed to build gem native extension. current directory: /tmp/bundler20191116-12860-iie6sqlite3-1.4.1/gems/sqlite3-1.4.1/ext/sqlite3 /usr/bin/ruby2.5 -r ./siteconf20191116-12860-3nvvhf.rb extconf.rb checking for sqlite3.h... no sqlite3.h is missing. Try 'brew install sqlite3', 'yum install sqlite-devel' or 'apt-get install libsqlite3-dev' and check your shared library search path (the location where your sqlite3 shared library is located). *** extconf.rb failed *** Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers. Check the mkmf.log file for more details. You may need configuration options. sqlite3 1.4.1가 제대로 설치되지 않았다고 나옵니다.\ngem install sqlite3 -v '1.4.1'을 해보니 마찬가지로 에러가 나와서 다음 명령어로 해결하였습니다.\nsudo apt-get install libsqlite3-dev sudo gem update bundle install 잘 설치되었습니다. rails를 한번 실행해봐야 곘네요.\nrails server 또, 에러 에러가 나오는 군요.\n/var/lib/gems/2.5.0/gems/webpacker-4.2.0/lib/webpacker/configuration.rb:95:in `rescue in load': Webpacker configuration file not found /home/ubuntu/blog/config/webpacker.yml. Please run rails webpacker:install Error: No such file or directory @ rb_sysopen - /home/ubuntu/blog/config/webpacker.yml (RuntimeError) webpacker을 설치해달라는 군요.\n우선, node.js를 설치해줍니다. 이후 yarn을 설치하고, webpacker를 설치했습니다.\ncurl -sL https://deb.nodesource.com/setup_13.x | sudo -E bash - sudo apt-get install -y nodejs curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - echo \u0026quot;deb https://dl.yarnpkg.com/debian/ stable main\u0026quot; | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install yarn rails webpacker:install 설치가 되었습니다. rails 서버도 기동하는 군요.\n  접속해보기 로컬 환경이였다면, 127.0.0.1:3000으로 접속이 가능했겠지만, ec2라서 살짝 설정을 바꿔주었습니다.\n포트를 80 을 접속 가능하도록 Security Group 설정 변경 EC2의 Security Group의 Inbound에 80포트를 설정해주었습니다.\n0.0.0.0:80 으로 서버 기동 rails server -b 0.0.0.0 -p 80 접속 EC2의 공인 ip로 접속해보았습니다.\n 서버 실행 중\n메인 화면\n 드디어 메인 화면이 나왔습니다. 이제부터는 본격적인 개발이 될 듯 하네요.\nCloud9 설정 그 전에, IDE를 설정했습니다.\nSSH 접속으로 설정하면 어떤 IDE도 사용할 수 있으나, AWS에 만들어 봤으니, IDE도 AWS를 사용해보았습니다.\nCloud9은 EC2로 처음부터 바로 환경 구축을 할 수도 있지만, 이번에는 미리 만든 EC2가 있으니 만들어 둔 EC2를 사용하였습니다.\nCreating an SSH Environment\n앞으로 계속 같은 ip 접속하기 위해 elastic ip을 할당하고, 위의 도움말에서 ~/.ssh/authorized_keys를 만드는 과정을 했습니다.\n이후, AWS Cloud9 Installer가 실행되어서 이것저것 설치되었습니다.\n  설치가 끝난 다음, 하단의 bash에 rails server -b 0.0.0.0 -p 80으로 서버를 실행하고 접속 할 수 있었습니다.\n이제 본격적으로 개발을 할 수 있겠네요.\n","ref":"/posts/2019-11-16-develop-using-cloud9/"},{"title":"ruby on rails를 ec2에 구축해보았습니다","date":"","description":"","body":"ruby를 알게 되었으니 ruby를 이용한 웹 사이트 한번 만들어보고싶어서 ruby on rails로 개발을 시작하였습니다.\n개발을 하면서 동시에 ruby on rails를 익히려는 목적이므로 기본적인 환경 구축부터 시작하였습니다.\nEC2 생성 AMI\n편하게 ubuntu(Ubuntu Server 18.04 LTS (HVM), SSD Volume Type)를 선택하였습니다.\n나머지 설정은 free-tier 가능한 설정으로 생성했습니다.\nSecurity groups\nSSH 접속 가능하게 22포트는 열어두고, 나머지는 나중에 설정하면서 열어주었습니다.\n클릭 몇 번에 생성이 끝났습니다. 고마워요. AWS\n설치 SSH로 접속해서, 차근차근 설치를 진행합니다.\nRuby on Rails 의 Getting Started with Rails 를 바탕으로 진행하였습니다.\n패키지 업데이트 sudo apt-get update Ruby 설치 sudo apt-get install ruby-full Ruby 버전 확인 ruby -v rails에서 요구하는 ruby 2.5.0이후 버전인지 확인합니다.\n  2.5.대 버전이군요.\nsqlite3 설치 sudo apt-get install sqlite3 sqlite3 버전 확인 sqlite3 --version rails 설치 드디어 rails를 설치할 차례입니다.\nsudo gem install rails 설치 에러  Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers.\n 설치 중간에 에러가 나왔습니다. Nokogiri 에서 일부 라이브러리가 없어서 생기는 에러 같군요.\nNokogiri 홈페이지에서 해결법을 찾아봅시다.\ninstall-with-system-libraries처럼 설치하니 되는 군요.\nsudo apt-get install pkg-config rails 설치를 계속 합니다.\nrails 버전 확인 rails --version   드디어 설치 완료했습니다. 중간에 에러 나서 당황했네요.\n다음엔, Creating the Blog Application으로 메인 화면까지 띄우도록 해보겠습니다.\n","ref":"/posts/2019-11-14-set-up-ruby-on-rails-ec2/"},{"title":"Blog에 댓글 기능을 추가하였습니다","date":"","description":"","body":"사용하고 있는 Minimal Mistakes 테마는 여러 댓글 서비스를 사용할 수 있게 설정 할 수 있어서, 사용해보았습니다.\n댓글을 사용할 페이지에 comment: true를 추가하고, _config.xml에 사용할 서비스와 정보를 입력하기만 하면 됩니다.\n이번에는 disqus라는 댓글 서비스를 사용해 보았습니다.\ndisqus에 가입한 뒤에 사이트를 생성해주고, ShortName을 알면 됩니다.\nshortname은 사이트를 생성할 때, 또는 생성하고 설정 화면에서도 알 수 있습니다.\n site생성\nsite설정\n 그런다음에, _config.xml 에 설정하면 됩니다.\n가입하고 테마에 사용 설정만 하면 되니 간단하네요.\n이제 확인 해봅시다.\n 안 보이네요.\n 이유를 찾아봅시다.\n이상합니다. 아무리 봐도 위의 설정으로 될 것 같은데요.\n그래서, Minimal Mistakes 테마에서 disqus와 관련된 comment소스를 찾아 봤습니다.\n _includes\\comments.html\n disqus를 위해 section을 만들고 있습니다.\n그래서 이번엔 해당 html을 include하는 파일을 찾아봤습니다.\n _layouts\\single.html\n single 레이아웃 페이지의 일부입니다.\n무언가의 조건으로 include를 하고 있는게 보입니다.\nsite.comments.provider 은 _config.xml 에서 설정했고, page.comments 는 true 로 설정해 두었죠.\n jekyll.environment == \u0026lsquo;production\u0026rsquo; 는 뭐죠?\n 아, Minimal Mistakes comment설정 의 Note가 이 내용인듯 하군요!\njekyll을 production환경으로 build하기 jekyll build 옵션에서 Environment를 설정할 수 있습니다.\n이 값는 jekyll.environment로 알아낼 수 있으며, build 설정에 따라 다른 결과물을 출력 할 수 있게 해줍니다.\nMinimal Mistakes 는 production으로 build된 경우에만 comment를 사용하도록 하였기 때문에, build시 Environment를 production으로 설정해야합니다.\nGitHub Pages에서 build를 하는 경우라면 자동적으로 production으로 설정되어 build가 되나, 필자는 local에서 build를 하고 있기에 따로 설정을 해주었습니다.\nlinux환경이였다면 Environment페이지 처럼 하면 되지만, windows라면 다릅니다.\ncmd인 경우\nset JEKYLL_ENV=production powershell인 경우\n$env:JEKYLL_ENV = \u0026#39;production\u0026#39; 해당 명령어 뒤에 build나 serve를 하면 production으로 만들어집니다.\n이로써, Minimal Mistakes 에 댓글 기능을 추가할 수 있었습니다.\n","ref":"/posts/2019-11-03-experience-using-comments-with-minimal-mistakes/"},{"title":"GitHub Pages에서 지원하지 않는 플러그인 쓰기","date":"","description":"","body":"jekyll을 공식적으로 지원하는 GitHub Pages이지만, 모든 jekyll의 플러그인까지 지원하는 것은 아닙니다.\nGitHub Pages는 지원하는 플러그인이 제한 되어있습니다.\n이 이외의 플러그인은 GitHub Pages에서 jekyll을 build할때, 제한되어 적용되지 않습니다.\n그럼, GitHub Pages에서 jekyll로 웹 페이지 서비스를 만들 때는 일부 플러그인만 사용해야 하는 것 일까요?\n반은 맞고 반은 틀립니다.\n알아보기 전에, 먼저 어떻게 GitHub Pages가 jekyll를 쓰는지 살펴봅시다.\nGitHub Pages with jekyll source\nGitHub Pages에서 jekyll을 쓰는 간단한 방법입니다.\n공식 도움말에서도 설명하는 방법처럼 jekyll 소스를 repository에 올려두고 GitHub Pages가 jekyll을 build를 하는 방법입니다.\nGitHub Pages에서 문제 없이 사용가능한 플러그인으로 제한을 하니, plugin의 호환성 같은 문제들에 대해 신경 덜 쓰고 만들 수 있다는 장점이 있습니다.\nGitHub Pages without jekyll source\nGitHub Pages는 기본적으로 정적 웹 페이지 호스팅 서비스이므로, jekyll소스가 아닌 웹 파일만 있어도 서비스가 가능합니다.\n즉, 무엇으로 만들었던, 서비스에 필요한 파일만 있으면 문제 없다는 것입니다.\n이러한 파일들은 jekyll로 build를 할 때, 하위 디렉토리인 _site에 생기니, 이 파일을 직접 GitHub Pages의 repository에 올려서 사용해도 문제 없이 서비스 할 수 있습니다.\nGitHub Pages에서 지원하지 않는 jekyll의 Plugin으로 만든 파일이라도 말이죠.\nGitHub Pages with an unsupported plugin 지원하지 않는 plugin이라도 로컬에서 build를 한 뒤에 웹 파일만 올리면, 서비스가 가능하게 됩니다.\n이를 위해서 우선 어떤 branch가 GitHub Pages로 설정 되어 있는지 확인 해 볼 필요가 있습니다.\nrepository의 settings에서 GitHub Pages라는 항목을 찾아 볼 수 있습니다.\n  저는 master branch를 사용중이라고 확인 할 수 있었습니다.\n그러므로, master branch에 jekyll로 build한 파일들을 올려두면, GitHub Pages를 서비스 할 수 있게 됩니다.\n소스랑 파일을 분리해서 관리\nmaster branch에 build된 파일을 올리니, 소스는 분리하고 싶어졌습니다.\n그래서 sources라는 branch를 만들고 소스는 해당 branch에만 push를 하고 있습니다.\n하지만, build된 파일은 master branch에 push해야 하니, 매번 branch를 변경해서 push를 해야하는 번거로움이 생겼습니다.\n이를 모두 수작업으로 하려면 실수도 하기 마련이고, 번거로우니 아래와 같은 PowerShell Script를 만들어서 자동화하였습니다.\nPowerShell Script\nchcp 65001 $env:JEKYLL_ENV = \u0026#39;production\u0026#39; rm -r _site/* git clone -b master https://github.com/DuiNaru/duinaru.github.io.git _site bundle exec jekyll build cd _site git add -A git commit -am \u0026#39;jekyll build\u0026#39; git push build시 문자 오류를 해결하기 위한 chcp 65001 과 jekyll을 production환경으로 build하기 위한 $env:JEKYLL_ENV = 'production'이 포함되어있습니다.\njekyll을 production환경으로 build를 해서 올리는 이유에 대해서는 다음에 설명하도록 하겠습니다.\n이걸로 지원하지 않는 플러그인이라도 GitHub Pages에 서비스 할 수 있게 되었습니다.\n","ref":"/posts/2019-10-26-how-to-make-a-github-pages-work-with-an-unsupported-plugin/"},{"title":"개발과 경험이 함께 하는 블로그","date":"","description":"","body":"평소에 생각하던 이것저것을 적어볼까 하다가 블로그를 만들게 되었습니다.\n블로그를 운영한다면 블로그 서비스를 이용하는 편이 간단하고 편할 듯 했지만, github.io 라는 도메인이 눈에 들어오더군요.\n그래서 github pages로 만들게 되었습니다.\n준비물 github\ngithub pages를 서비스할 repository를 만들었습니다.\njekyll\ngithub pages는 jekyll을 지원합니다.\njekyll로 만든 소스를 repository에 올려 두는 것 만으로도 빌드-배포를 해주죠.\nruby\njekyll로 만들려면 ruby가 필요합니다.\nbuild를 하거나, plugin을 설치해서 기능을 추가해볼 수 있습니다.\n만들기 ruby\njekyll의 build와 여러 plugin을 설치하기 위해 설치해주었습니다.\njekyll 공식 홈페이지에 사용 방법이 친절히 적혀있어서 별 어려움이 없었습니다.\n다국어 지원\n적어도 2개국어로 운영할 생각이니, 다국어 지원을 위해 polyglot plugin을 설치해 주었습니다.\n이 플러그인이 github pages에서 공식적으로 지원하는 플러그인이 아니기에, 단순히 repository에 소스를 올려두는 것으로 빌드가 되지 않습니다.\n하지만, 다 방법이 있죠.\n테마 선택하기\n이 과정에서 시간이 상당히 걸렸습니다.\n이걸로 해볼까 저걸로 해볼까 하면서 고르다가 시간이 순식간에 지나가네요.\n결국에는 Minimal Mistakes로 하기로 했습니다.\n하지만, 여기서 문제가 발생하였습니다.\n build할 때, 에러가 발생해요.\npolyglot plugin이 작동하질 않아요.\n 문제 해결 windows환경에서 build할 때, 문자 관련 에러 해결\nruby를 windows환경에서 쓰려다 보니 발생하는 에러 였습니다.\n  vscode에서 cmd로 빌드 하고 있었기에, chcp 65001 을 이용해서 UTF-8로 바꿔서 해결했습니다.\n다르게는 jekyll을 에러가 발생하지 않는 버전으로 바꾸는 방법도 있으나, 아래의 문제로 인해 버전을 제한 할 수 밖에 없었습니다.\nMinimal Mistakes과 polyglot plugin을 함께 사용하기\n웹 페이지가 제대로 만들어 지지 않는 문제가 발생하였습니다.\n시행착오 끝에, 다음과 같이 해결이 되었습니다.\njekyll버전\njekyll를 3.8.6으로 사용하니, polyglot plugin과 함께 작동합니다.\npolyglot plugin의 _config.xml설정\n  languages의 언어 설정 순서를 default_lang에서 설정한 언어를 먼저 오게 설정하니 polyglot plugin이 잘 작동합니다.\n기능 추가 언어 선택\n다국어 지원을 위해 언어를 바꾸는 기능을 추가해 주었습니다.\n페이지 하단에 보이는 KO나 JA같은 것이죠.\n댓글\nMinimal Mistakes에서도 지원하는 disqus를 이용해서 추가했습니다.\n후기 만들다 보니 시간이 꽤나 흘렀습니다.\n앞으로는 글도 쓰면서, 이것저것 업데이트 해 볼까 합니다.\n","ref":"/posts/2019-10-23-blog-with-development-and-experience/"}]